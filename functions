#!/bin/bash

source config
# config is where data is stored for the functions file, this is in the form of Bash variables

#-------------------#
# General Functions #
#-------------------#

dir_setup () {
# Simple one line function to create a working directory if it doesn't already exist.
# arg 1 is working directory name, this will always be the tool name, ex: annovar 
	if [ -d "$code_base_loc/$1" ]; then
		post_to_log "checked for directory for $1, it exists"
		exit
	else
		(cd $code_base_loc && mkdir $1)
		post_to_log "created directory for $1"
	fi;
}

automated_download () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	working_dir=$1
	eval_type; eval_url; eval_user;
	
	log_check
	dir_setup "$working_dir"

	case "$code_type" in
	"git_github" ) 
		post_to_log "we have a $code_type, attempting an automatic download"
	;;
	"wget_special" ) 
		post_to_log "we have a $code_type, attempting an automatic download"
	;;
	"wget_source_forge" ) 
		post_to_log "we have a $code_type, attempting an automatic download"
	;;
	"pypi" ) 
		post_to_log "we have a $code_type, attempting an automatic download"
	;;
	"hg_bitbucket" ) 
		post_to_log "we have a $code_type, attempting an automatic download"
	;;
	"rsync" ) 
		post_to_log "we have a $code_type, attempting an automatic download"
	;;
	* )	
		post_to_error "code type $code_type does not exist, not source downloaded, exiting"
		break
	;;
	esac
}

check_type () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

current_downloaded_version () {
# just a tail in the working directory to get the latest commit/version/whatever
# arg 1 is working directory name, this will always be the tool name, ex: annovar 
	(cd "$/code_base_loc/$1" && tail -n 1 "${1}_data") 
}

eval_type () {
# evaluates the type of code that we are working on, this is used in the automated download feature
# arg 1 is working directory name, this will always be the tool name, ex: annovar 
	eval code_type=\$"${1}_type"
}

eval_url () {
# evaluates the url using the working directory name
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
    eval code_url=\$"${1}_url"
}

eval_user () {
# evaluates the user using the working directory name
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	eval code_user=\$"{1}_user"
}

#---------------#
# Git Functions #
#---------------#

git_update () {
# Updates the git repo holding the code 
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	(cd "$code_base_loc/$1/$2" && git pull)
	(cd "$code_base_loc/$1" && git rev-parse HEAD >> "$code_base_loc/$1_git_data")
}

github_download_tar () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

github_latest () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

github_automated_download () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

#----------------#
# Wget Functions #
#----------------#

wget_in_dir () {
# wgets the code in the working direcory
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
# arg 2 is the complete url to the pacakge
    ( cd "$code_base_loc/$1" && wget $2  )
}

sourceforge_latest () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

sourceforge_automated_download () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

#----------------#
# PyPi Functions #
#----------------#

pypi_latest () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

pypi_automated_download () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

#------------------------#
# BitBucket Hg Functions #
#------------------------#

bitbucket_latest () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

bitbucket_automated_download () {
# arg 1 is the working directory name, this will always be the tool name, ex: annovar
	echo "not implemented"
}

#---------------#
# Log Functions #
#---------------#

log_check () {
#doesn't take any arguments, just checks to make sure that logging is going to work, or its off. 
if [ $logging = "on" ]; then
	[ -d $log_file ] || echo "error: log directory \"$log_file\" (log files) not found, quiting"; break
	[ -d $error_file ] || echo "error: log directory \"$error_file\" (error files) not found, quiting"; break
elif [ -z $logging ]; then
	echo "ok... no logging then"
else
	echo "error: \$logging is set to \"$logging\" which is not valid, quiting"
	break
fi
}

post_to_error () {
	echo "[$(date)]: $0 $1" >> "$log_file/latest_sauce_$(date +%e_%m_%Y)"
}

post_to_log () {
	echo "[$(date)]: $0 $1" >> "$error_file/latest_sauce_err_$(date +%e_%m_%Y)"
}
